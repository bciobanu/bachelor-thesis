\chapter{Context}

\section{Concepte din algebra liniara}

\begin{defn}
  Un \textbf{monoid} $G = (A, \circ)$ este o structura algebrica formata dintr-o
  multime $A$ si o lege de compozitie asociativa si cu element neutru.
\end{defn}

\begin{defn}
  Un \textbf{grup} $G = (A, \circ)$ este o structura algebrica formata dintr-o
  multime $A$ si o lege de compozitie care respecta urmatoarele proprietati:
  \begin{itemize}
      \item{$\forall\ x_{1}, x_{2} \in G, x_{1} \circ x_{2} \in G$.}
      \item{$\forall\ x_{1}, x_{2}, x_{3} \in G, (x_{1} \circ x_{2}) \circ x_{3} = x_{1} \circ (x_{2} \circ x_{3})$.}
      \item{$\exists\ e \in G \text{ astfel
      incat } \forall\ x \in G\ e \circ x = x \circ e = x$.}
      \item{$\forall\ x_{1} \in G\ \exists\ x_{2} \in G \ x_{1} \circ x_{2} = x_{2} \circ x_{1} = e$.}
  \end{itemize}
  In plus, acesta este abelian daca
  $\forall\ x_{1}, x_{2} \in G\ x_{1} \circ x_{2} = x_{2} \circ x_{1}$.
\end{defn}

\begin{defn}
  Un \textbf{inel} $I = (A, +, *)$ este o structura algebrica formata dintr-o
  multime $A$ si doua operatii binare definite pe $A \times A$ cu valori tot in
  $A$, care respecta urmatoarele proprietati:
  \begin{itemize}
      \item{$(A, +)$ este un grup abelian.}
      \item{$(A, *)$ este un monoid.}
      \item{Distributivitatea lui $*$ fata de $+$.}
  \end{itemize}
\end{defn}

\begin{defn}
  Un \textbf{polinom} este o expresie construita dintr-una sau mai multe
  variabile si constante, folosind doar operatii de adunare, scadere, inmultire
  si ridicare la putere constanta pozitiva intreaga.
\end{defn}

\begin{defn}
  O \textbf{matrice} este un tabel dreptunghiular de elemente ale unui inel.
\end{defn}

\subsection{Interpolare Lagrange}

\textbf{Polinomul de interpolare Lagrange} este un polinom $P$ construit in asa
fel incat avand $k + 1$ perechi
$(x_{1}, y_{1}), (x_{2}, y_{2}), \ldots, (x_{k+1}, y_{k+1})$ avem ca
$P(x_{i}) = y_{i}\ \forall\ 1 \leq i \leq K + 1$. \par
Constructia lui $P$ a fost oferita de Joseph Louis Lagrange in $1795$:
\begin{equation}
  P(x) := \sum_{i_{1}=0}^{k} (y_{i_{1}} * \prod_{1 \leq i_{2} \leq k + 1 \ \land \ i_{1} \neq i_{2}} \frac{x - x_{i_{2}}}{x_{i_{1}} - x_{i_{2}}})
\end{equation}

\section{Teoria grafurilor}

\begin{defn}
  Un \textbf{graf neorientat} este o pereche ordonata $G(V, E)$, unde:
  \begin{itemize}
    \item{$V$ este multimea de noduri}.
    \item{$E \subseteq \{(x, y)\ |\ (x, y) \in V^2 \land x \neq y\}$ este
      multimea de muchii, care sunt perechi neordonate de noduri}.
  \end{itemize}
\end{defn}

\begin{defn}
  Un \textbf{graf bipartit} este un graf neorientat $G(V, E)$ ale carui noduri pot fi
  partitionate in doua multimi disjuncte $V_{1}$ si $V_{2}$, altfel incat fiecare muchie
  conecteaza un nod din multimea $V_{1}$ cu un nod din multimea $V_{2}$. Atunci,
  se va nota cu $G(V_{1}, V_{2}, E)$.
\end{defn}

\begin{defn}
  Un \textbf{cuplaj} intr-un graf este o multime de muchii fara noduri in comun.
\end{defn}

\begin{defn}
  \textbf{Matricea Edmonds} $A$ a grafului bipartit $G(U, V, E)$, unde
  $U = \{u_{1}, u_{2}, u_{3}, \ldots, u_{n}\}$,
  $V = \{v_{1}, v_{2}, v_{3}, \ldots, v_{n}\}$ si $x_{i,j}$ indeterminate, se defineste ca:
   \begin{equation}
    A=
    \begin{cases}
      x_{i,j} & \text{daca}\ (u_{i}, v_{j}) \in E \\
      0 & \text{altfel}
    \end{cases}
  \end{equation}
\end{defn}

\begin{thm}
  \label{edmonds}
  Un graf bipartit $G(U, V, E)$ admite cuplaj perfect daca si numai daca
  polinomul determinantului matricei sale Edmonds nu este polinomul nul.
\end{thm}

\begin{clr}
  Numarul de cuplaje perfecte este egal cu numarul monoamelor in polinomul $det(A_{i,j})$.
\end{clr}

\begin{clr}
  Rangul matricei Edmonds este egal marimea cuplajului maximal.
\end{clr}

\pagebreak

\section{Lema Schwartzâ€“Zippel}
\textbf{Lema Schwartz-Zippel} este o metoda utila pentru a verifica intr-un mod
probabilistic daca un polinom in mai multe variabile este polinomul nul.
% TODO: poate discutie despre autori?

\begin{thm}
  Fie $P \in F \lbrack x_{1}, x_{2}, \ldots, x_{n} \rbrack$ un polinom nenul de grad $d \geq 0$
  peste corpul $F$ si $S$ o submultime finita a lui $F$. Alegem
  $r_{1}, r_{2}, \ldots, r_{n}$ uniform aleator si independent din $S$. Atunci:
  \begin{equation}
    \Pr \lbrack P(r_{1}, r_{2}, \ldots, r_{n}) = 0 \rbrack \leq \frac{d}{|S|}
  \end{equation}
\end{thm}

Acest rezultat are sens odata ce ne gandim pe cazul de baza, cand $n=1$ deoarece
un polinom de grad $d$ are cel mult $d$ radacini. Intreaga demonstratie se
bazeaza pe inductie matematica si se poate consulta in \cite{schwartzzippel}.

\begin{thm}
  Lema Schwartz-Zippel se poate folosi in \ref{edmonds} pentru a verifica
  existenta unui cuplaj perfect in timp polinomial.
\end{thm}

Fie $A$ \textbf{matricea Edmonds} asociata grafului. $\det(A)$ este un polinom
in $n^{2}$ variabile, de grad $n$. Alegem corpul pe care lucram ca fiind
$\mathbb{F}_{p}$. Determinantul poate fi calculat sub $\mathbb{F}_{p}$ in timp $O(n^{3})$
folosind Eliminare Gaussiana. Chiar mai mult decat atat, acest calcul
poate fi facut in timp $O(\log^{2} n)$ daca avem la dispozitie $O(n^{3.5})$
procesoare \cite{paralleldet}. Probabilitatea de esec a algoritmului este de $\frac{n}{p}$.

\pagebreak

\section{Lema de izolare}
\textbf{Lema de izolare} este o metoda de a reduce numarul de solutii ale unei
probleme la una singura, daca aceasta exista. Aceasta se obtine prin adaugarea
unor constrangeri aleatoare in asa fel incat, cu o probabilitate neglijabila,
va exista o singura solutie care satisface constragerile aditionale.

Lema a fost introdusa de Valiant si Vazirani in lucrarea ``NP is as easy as
detecting unique solutions'', publicata in 1986.

\begin{thm}
  \label{isolation}
  Fie $n$ si $m$ doua numere intregi pozitive si $F$ o familie de submultimi a
  lui $\{1, 2, \ldots n\}$. Fie
  $w : \{1, 2, \ldots, n\} \to \{1, 2, \ldots, m\}$ o functie care asociaza
  valori uniform aleatoare si independente din codomeniu. Atunci, cu o
  probabilitate de cel putin $1 - \frac{n}{m}$, va exista o singura multime $S$ in
  $F$ pentru care $\sum_{x\in S}{w(x)}$ este minima.
\end{thm}

\pagebreak

\section{Algoritm paralelizabil pentru cuplaj}
\label{Algoritm paralelizabil pentru cuplaj}

In ``Matching is as easy as matrix inversion'' \cite{matchingezmatrix} se
descrie o metoda pentru a cauta cuplajul perfect folosind acest rezultat.
Consideram $G(U, V, E)$ un graf bipartit. Asociem fiecarei muchii din $E$ un
cost uniform din multimea $\{1, 2, \ldots, 2|E|\}$. Conform \ref{isolation}, cu
probabilitate de cel putin $\frac{1}{2}$ va exista un cuplaj unic de cost minim.
Consideram $U = \{u_{1}, u_{2}, u_{3}, \ldots, u_{n}\}$,
$V = \{v_{1}, v_{2}, v_{3}, \ldots, v_{n}\}$ si costul aleator ales mai devreme muchiei
$(u_{i}, v_{j})$ ca fiind $w_{i,j}$. Fie $A$ matricea Edmonds a acestui
graf, construita in felul urmator:
\begin{equation}
A=
\begin{cases}
  2^{w_{i,j}} & \text{daca}\ (u_{i}, v_{j}) \in E \\
  0 & \text{altfel}
\end{cases}
\end{equation}

Definim costul unui cuplaj ca fiind suma costurilor muchiilor alese in acea multime.
\begin{lem}
  Daca $p$ este costul cuplajului minim si acesta este si unic, atunci $\det(A) \neq 0$, iar
  $2^{p} \ |\ \det(A)$ si $2^{p+1} \not| \ \det(A)$.
\end{lem}

Fie $\text{sgn} : S_{n} \to \{\pm 1\}$, $\text{sgn}(P)$ este $+1$ daca $P$
este permutare para, altfel $-1$. $\text{sgn}(P)$ se numeste signatura
permutarii $P$.

\begin{equation}
  \label{isolationdet}
  \det(A) = \sum_{P \in S_{n}} (\text{sgn}(P) * \prod_{1 \leq i \leq N} A_{i, P_{i}})
\end{equation}

Pentru fiecare cuplaj din $G$ putem asocia unic o permutare $P$ din $S_{n}$:
daca muchia $(u_{i}, v_{j})$ este aleasa in cuplaj, atunci $P_{i} \equiv j$.
Pentru o permutare care nu are asociat un cuplaj perfect, aceasta nu va
contribui deloc la valoarea expresiei \ref{isolationdet}. \par

Daca $P$ este permutarea asociata cuplajului de cost minim, atunci
$\prod_{1 \leq i \leq N} A_{i, P_{i}} = 2^{p}$. Valoarea celorlalte permutari
este fie $0$, fie o putere de $2$ mai mare decat $2^{p}$ (deoarece $P$ este
unica). Asadar, valoarea determinatului o sa fie divizibila cu $2^{p}$ si
mai mult, aceasta va fi cel mai mare divizor de aceasta forma.

\pagebreak

Pentru a determina multimea muchiilor din cuplaj, trebuie sa mai notam cateva observatii.

\begin{lem}
  Fie $A'$ matricea obtinuta eliminand linia $i$ si coloana $j$. Fie
  $C \def \det(A') * \frac{2^{w_{i,j}}}$. Muchia
  $(u_{i}, v_{j})$ face parte din cuplaj daca si numai daca $2^{p} \ | \ C$,
  $2^{p+1} \not| \ C$ si $C \neq 0$.
\end{lem}

In primul rand, valoarea $\det(A') * 2^{w_{i,j}}$ este chiar valoarea
determinantului calculat dupa formula de la \ref{isolationdet}, cu precizarea ca
se vor consider doar permutarile $P$ cu $P_{i} = j$. Acest lucru se datoreaza
faptului ca permutarile alese in calculul lui $\det(A')$ vor avea cu un element
mai putin decat cele din $\det(A)$, iar pentru elementul lipsa inmultim mereu cu
valorea asociata muchiei $(u_{i}, v_{j})$, adica $2^{w_{i,j}}$.
Aplicand apoi observatiile demonstratiei pentru \ref{isolationdet} obtinem
rezultatul dorit si in cele din urma, un algoritm pentru determinarea cuplajului
perfect care nu se bazeaza pe retele de flux, ci doar pe obiect de algebra
liniara: \par

\vspace{5 mm}

\begin{algorithm}[H]
 \label{cuplajizolare}
 \KwData{Graf bipartit G(U, V, E) care admite cuplaj perfect}
 \KwResult{Multimea muchiilor alese intr-un posibil cuplaj perfect}
 \Begin{
  determina w\;
  construieste A\;
  $p \longleftarrow \det(A)$\;
  $C \longleftarrow \{\}$\;
  \For{$(u_{i}, v_{j}) \in E$}{
    determina $A'$\;
    \If{$\frac{\det(A') * 2^{w_{i,j}}}{2^{p}} \mod 2 = 1$}{
      $C \longleftarrow C \cup \{(u_{i}, v_{j})\}$\;
    }
  }
  \Return{$C$}\;
 }
 \caption{Cuplaj perfect lema de izolare}
\end{algorithm}

\pagebreak

In continuare vom presupune ca putem efectua operatiile aritmetice de baza in timp $O(1)$.
Atunci algoritmul \ref{cuplajizolare} dureaza $O(n^{5})$, daca folosim
algoritmul lui Gauss pentru calcularea determinantului. Putem sa nu recalculam
valoarea determinantului la fiecare iteratie folosind:
\begin{equation}
  \det(A + uv^{T}) = (1 + v^{T} A^{-1} u) \det(A)
\end{equation}

Cu aceasta proprietatea a determinantului, cunoscuta si ca \textbf{Matrix
  determinant lemma} putem reduce complexitatea la $O(n^{4})$. In plus,
algoritmul se poate paraleliza bine, deoarece determinantul unei matrice
de marime $n \times n$ se poate calcula in timp $O(\log^{2}n)$ pe $O(n^{3.5})$ procesoare.

Unicitatea solutiei, garantata de \textbf{lema de izolare} permite procesoarelor
sa execute si pasul urmator, in care se testeaza o muchie daca face parte din
cuplaj, in paralel, deoarece se indreapta catre aceeasi solutie, cu o
certitudine destul de mare. Asadar si aceasta parte a algoritmului poate fi
calculata in timp polilogaritmic, daca avem la dispozitie un numar polinomial de
procesoare.

Deja se comporta mai prost decat algoritmii clasici de flux si inca nu am adus in discutie costul de
a lucra cu numere intregi de ordinul $O(4^{n^{4}})$, adica numere intregi cu
$2 * n^{4}$ biti. Avem nevoie de operatia de inmultire pe aceste numere, iar
aceasta nu se poate executa mai bine de $O(n^{4}\log n)$, rezultat recent
obtinut de algoritmul Harvey-Hoeven in 2019.
De asemenea, in ipoteza curenta algoritmul nu este determinist si
are probabilitate de succes de $\frac{1}{2}$, deci trebuie rulat de mai multe
ori pentru a gasi un rezultat de certitudine mare.

\pagebreak

\section{Cuplaj rosu-albastru}
\label{redbluematching}

Sa consideram un graf bipartit $G(U, V, E)$, unde $E_{1}$ este multimea
muchiilor rosii, $E_{2}$ este multimea muchiilor albastre, iar
$E = E_{1} \cup E_{2}$. Dorim sa alfam daca exista un cuplaj perfect
in care se folosesc exact $k$ muchii rosii, stiind ca daca acesta exista, atunci
este si \textbf{unic}. \par

Aceasta problema nu se poate rezolva cu algoritmi de flux maxim, spre deosebire
de celelalte probleme de pana acum. Totusi, avem sanse sa o rezolvam, daca
procedam prin a modifica \textbf{matricea Edmonds} cat sa avem un mod de a ne da seama de
culoarea muchiilor alese in cuplaj:

\begin{equation}
  A=
  \begin{cases}
    y & \text{daca}\ (u_{i}, v_{j}) \in E_{1} \\
    1 & \text{daca}\ (u_{i}, v_{j}) \in E_{2} \\
    0 & \text{altfel}
  \end{cases}
\end{equation}

$\det(A)$ va fi un polinom in $y$ de grad $n$. $G$ va avea un cuplaj perfect cu
$k$ muchii rosii daca coeficientul lui $y^{k}$ va fi nenul. Pentru a determina
acest numar putem sa interpolam polinomul $\det(A)$ folosind interpolarea
Lagrange. Tot ce ramane de facut este sa evaluam polinomul in $n+1$ puncte. \par

Pentru cazul general, cand cuplajul rosu-albastru nu este neaparat unic, putem
folosi una din cele doua leme sa reducem problema la una mai simpla.

\subsection{Folosind Lema Schwartz-Zippel}

Pentru fiecare muchie $(u_{i}, v_{j})$ alegem o valoarea aleatoare $x_{i,j}$ dintr-o
multimea $S$. Construim matricea astfel:

\begin{equation}
  A=
  \begin{cases}
    y * x_{i,j} & \text{daca}\ (u_{i}, v_{j}) \in E_{1} \\
    x_{i,j} & \text{daca}\ (u_{i}, v_{j}) \in E_{2} \\
    0 & \text{altfel}
  \end{cases}
\end{equation}

Ca inainte, vom interpola $\det(A)$ pentru a afla coeficientul lui $y^{k}$.
Acest coeficient trebuie sa fie nenul. Iar acum, cu probabilitate mare, acest
lucru este adevarat, pentru ca daca doua polinoame se ``anuleaza'' unul pe
celalalt in urma calculului determinantului, atunci cu probabilitate de cel mult
$\frac{n}{|S|}$ acestea erau diferite.

\subsection{Folosind Lema de izolare}
Asemanator algoritmului prezentat la \ref{Algoritm paralelizabil pentru cuplaj}
si solutiei precedente cu Lema Schwartz-Zippel, avand valorile $w_{i,j}$ alese
din $\{1, 2, \ldots, 2|E_{1} \cup E_{2}|\}$, vom construi matricea astfel:

\begin{equation}
  A=
  \begin{cases}
    y * 2^{w_{i,j}} & \text{daca}\ (u_{i}, v_{j}) \in E_{1} \\
    2^{w_{i,j}} & \text{daca}\ (u_{i}, v_{j}) \in E_{2} \\
    0 & \text{altfel}
  \end{cases}
\end{equation}

In continuare ramane sa ne uitam la coeficientul lui $y^{k}$ in $\det(A)$. Spre
deosebire de lema \textbf{Schwartz-Zippel}, acesta varianta are posibilitatea sa fie
paralelizabil, deoarece, cu probabilitate de cel putin $\frac{1}{2}$, cuplajul
pe care vrem sa-l gasim este acum unic.

\pagebreak

\section{Transformari Fourier}

\subsection{Transformarea Fourier Discreta}
Consideram $n = 2^{p}$ si urmatorul polinom de grad $n-1$:
\begin{equation}
  A = a_{0}x^{0} + a_{1}x^{1} + \ldots + a_{n-1}x^{n-1}
\end{equation}

Solutia ecuatiei $x^{n} = 1$ are $n$ solutii in multimea numerelor complexe.
Acestea sunt de forma $w_{p} = e^{\frac{2k\pi i}{n}}$ pentru $p$ un numar intreg
intre $0$ si $n-1$. Aceste radacini au multe proprietati utile, iar cea pe care
urmeaza sa o folosim este ca $w_{p} = w_{0}^{p}$. \par
\textbf{Transformarea discreta Fourier} a polinomului $A$ este definita ca fiind
vectorul obtinut prin evaluarea polinomului in radacinile unitatii:

\begin{equation}
  \label{dft}
  \text{DFT}(A) = (A(w_{0}), A(w_{1}), \ldots, A(w_{n-1})) \\
                = (A(w_{0}^{1}), A(w_{0}^{2}), \ldots, A(w_{0}^{n-1}))
\end{equation}

Similar, avand vectorul din partea dreapta a ecuatiei \ref{dft}, \textbf{inversa
transformarii discrete Fourieri} reconstituie coeficientii polinomului $A$:
$(a_{0}, a_{1}, \ldots a_{n-1})$. Vom nota aceasta transformare cu
$\text{InverseDFT}$. \par

O aplicatie utila este inmultirea polinoamelor. Fie $\textbf{dot}$ operatia de
inmultire scalara a doi vectori. Aceasta se bazeaza pe o
proprietatea a transformarii, si anume:
\begin{equation}
  \text{DFT}(A * B) = \text{dot}(\text{DFT}(A), \text{DFT}(B))
\end{equation}

Aceasta proprietate este utila, fiind la baza unui algoritm rapid de inmultire a
polinoamelor, deoarece $\text{DFT}(A)$ si $\text{InverseDFT}(A)$ se pot calcula
in timp $O(n \log n)$.

\subsection{Transformarea Hadamard}

\textbf{Transformarea Hadamard} este o transformare Fourier generalizata,
executand o operatie liniara pe $2^{n}$ numere reale. Aceasta este echivalenta
cu o transformare discreta $n$-dimensionala Fourier de marime
$2 \times 2 \ldots \times 2$. In mod intuitiv, se inmultesc monoame a $n$
variabile, aplicandu-se modulo $x^{2}-1$ pe fiecare variabila. Fie $p_{i_{1}, i_{2}} \in \{0, 1\}$:
\begin{equation}
  A = a_{0} x_{0}^{p_{0, 0}} x_{1}^{p_{0, 1}} \ldots x_{n-1}^{p_{0, n-1}}
  + a_{1} x_{0}^{p_{1, 0}} x_{1}^{p_{1, 1}} \ldots x_{n-1}^{p_{1, n-1}}
  + \ldots
  + a_{n-1} x_{0}^{p_{n-1, 0}} x_{1}^{p_{n-1, 1}} \ldots x_{n-1}^{p_{n-1, n-1}}
\end{equation}

Daca in cazul \textbf{transformarii Fourieri discrete} obtineam
$C_{i+j} = \sum A_{i} B_{j}$, in cazul \textbf{transformarii Hadamard} obtinem
$C_{i \oplus j} = \sum A_{i} B_{j}$, unde $\oplus$ este operatia de sau exclusiv
(xor) pe biti. Intuitiv, de ce se obtine operatie de xor este pentru ca
cele $n$ monoame reprezentau bitii fiecarui numar de la $0$ la $2^{n} - 1$.
Acestora la inmultire li se aplica modulo $x^{2} - 1$, asemanator bitilor in
timpul unei operatii de xor, care este ca o adunare, in urma careia se aplica
modulo $2$, totul efectuat separat pe fiecare bit in parte.

\subsection{Algoritmul Fast Walsh-Hadamard}

\textbf{Algoritmul Fast Walsh-Hadamard} este un algoritm eficient pentru a
calcula \textbf{transformarea Hadamard}. O implementare naiva a transformarii
necesita complexitate de timp $O(2^{2n})$, in timp ce algoritmul pe care urmeaza
sa-l prezentam necesita doar $O(n2^{n})$. Algoritmul se bazeaza pe paradigma
divide et impera, impartind o problema de marime $2^{n}$ in doua de marime
$2^{n-1}$, urmarind definitia recursiva a matricei Hadamard:

\begin{equation}
  \label{hadamardmatrix}
  H_{n} =
  \begin{pmatrix}
    H_{n-1} & H_{n-1}\\
    H_{n-1} & -H_{n-1}
  \end{pmatrix}
\end{equation}

Ecuatia \ref{hadamardmatrix} omite factorul de normalizare de
$\frac{1}{\sqrt{2}}$, care poate fi aplicat la final.

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetKwFunction{FMain}{FWHT}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\FMain{$a$, $n$}}{
    \If{$n = -1$}{
      \KwRet\;
    }
    offset := $2^{n - 1}$\;
    \FMain($a[0 \ldots \text{offset}]$, n - 1)\;
    \FMain($a[\text{offset} \ldots 2^{n}]$, n - 1)\;
    \For{i in $0 \ldots 2^{n}$}{
      x := $a_{i}$\;
      y := $a_{i + \text{offset}}$\;
      $a_{i}$ := x + y\;
      $a_{i + \text{offset}}$ := x - y\;
    }
    \KwRet\;
  }
  \;
\end{algorithm}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetKwFunction{FMain}{IFWHT}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\FMain{$a$, $n$}}{
    \If{$n = -1$}{
      \KwRet\;
    }
    offset := $2^{n - 1}$\;
    \FMain($a[0 \ldots \text{offset}]$, n - 1)\;
    \FMain($a[\text{offset} \ldots 2^{n}]$, n - 1)\;
    \For{i in $0 \ldots 2^{n}$}{
      x := $a_{i}$\;
      y := $a_{i + \text{offset}}$\;
      $a_{i}$ := x - y\;
      $a_{i + \text{offset}}$ := x + y\;
    }
    \KwRet\;
  }
  \;
\end{algorithm}

\pagebreak

\section{Algoritmul lui Coppersmith}

In cadrul algoritmilor de algebra liniara pentru cuplaj avem des problema de a
calcula determinanti. De obicei, aceste grafuri nu vor fi atat de dense, deci
nici matricea Edmonds (\ref{edmonds}) nu va avea multe elemente nenule.

\textbf{Algoritmul lui Coppersmith} \cite{wiedemann} este un algoritm rapid pentru calcularea
vectorilor nucleu al unei matrice intr-un corp finit. Acesta este in particular
eficient pentru matricele rare, cele care nu au atat de multe elemente nenule. \\

Consideram $A$ o matrice patratica de marime $n \times n$ peste un corp finit $F$, atunci:

\begin{defn}
  Polinomul caracteristic al lui $A$ este definit ca
  $p(\lambda) = \det(\lambda I_{n} - A)$.
\end{defn}

\begin{thm}
  \label{cayleyhamilton}
  \textbf{Cayley-Hamilton} spune ca fiecare matrice patratica intr-un inel
  comutativ isi satisface ecuatia caracteristica, mai exact $p(A) = 0$.
\end{thm}

$A$ are un polinom monic $P$ peste corpul $F$ de grad minim pentru care
$P(A) = 0$. $P$ se numeste polinomul minim al lui $A$. In
cazul matricelor rare, ne asteptam ca acest polinom sa aiba un grad mai mic
decat cel al polinomului caracteristic. $P$ mereu va divide polinomul
caracteristic, iar din \ref{cayleyhamilton}, gradul acestuia nu va fi mai mare
de $n$. Fie $P = a_{0} + a_{1}x + \ldots + a_{n'}x^{n'}$, unde $n' \leq n$.

\begin{lem}
  \label{polminimdet}
  Daca $n' = n$, atunci $P$ este chiar polinomul caracteristic al lui $A$, iar
  determinantul este chiar $(-1)^{n}P(0)$.
\end{lem}

\begin{lem}
  Putem folosi polinomul minimal pentru a calcula determinantul matricei $A$.
\end{lem}

\begin{proof}
  Fie $d$ un vector de $n$ elemente
  alese uniform aleator si independent din $F$, iar
  $D =
  \begin{bmatrix}
    d_{1} & 0 & \dots \\
    0 & d_{2} & \dots \\
    \vdots & \ddots & \\
    0 & \dots & d_{n}
  \end{bmatrix}$. Conform lemei Schwartz-Zippel, matricea $AD$ este singulara cu
  probabilitate de cel mult $\frac{n}{|F|}$. In cazul in care nu este, atunci ne
  asteptam ca polinomul minim sa aiba grad egal chiar cu $n$. In acest caz,
  putem calcula rapid $\det(AD)$ folsind \ref{polminimdet} si apoi sa aflam
  $\det(A) = \frac{\det(AD)}{det(D)}$, iar $\det(D) = \prod_{i=1}^{n} d_{i}$.
\end{proof}

Fie $x'$ un vector de $n$ elemente alese uniform aleator si independent din $F$,
iar $x = Ax'$. Fie $S = [x, Ax, A^{2}x, \ldots]$.
Consideram un alt vector de $n$ elemente, $y$ si urmatorul sir de valori din $F$: $[yx, yAx, yA^{2}x, \ldots ]$.

Stim ca $P(A) = 0$, atunci $\sum_{i=0}^{n'} a_{i} A^{i} = 0$. Obtinem ca si
$\sum_{i=0}^{n'} y (a_{i} (A^{i} x)) = 0$. Intuitiv, stim ca $P(S) = 0$, insa nu
stim sa calculam eficient o secventa $b_{0}, b_{1}, \ldots b_{k}$ astfel incat
$\sum_{i=0}^{k} b_{i} S_{i+o} = 0 \ \forall \ o \geq 0$, pentru ca elementele din $S$ sunt vectori, insa
atunci cand reducem la cazul cu valori, o sansa destul de mare ca secventa $b$
care anihileaza $yS$ sa anihileze si $S$, deci
$\sum_{i=0}^{k} b_{i} M^{i}x = 0$.
Inlocuind cu $x = Ax'$, obtinem ca $M \sum_{i=0}^{k} b_{i} M^{i} x' = 0$, deci
daca $b_{i} M^{i} x'$ este nenul, atunci am obtinem un nucleu al lui $M$.

Pentru a calcula elementele secventei $S$ se folosesc algoritmi pentru gasirea
\textbf{polinomului minim al unei recurente liniare}. Algoritmul
\textbf{Berlekamp Massey} daca $|F|$ este un numar prim (doua corpuri de
aceeasi marime sunt izomorfe), altfel, se factorizeaza
$|F| = p_{1}^{k_{1}} p_{2}^{k_{2}} \ldots p_{t}^{k_{t}}$ si se rezolva $t$
probleme cu $|F_{i}'| = p_{i}^{k_{i}}$ cu algoritmul \textbf{Reeds-Sloane}, iar
rezultatele se combina folosind teorema chineza a resturilor. In ce urmeaza vom
prezenta un alt algoritm echivalent care nu foloseste impartiri, deci nu este
constans la un tip de corp anume \cite{sugiyama}.

\pagebreak

\section{Polinomul minim al unei recurente liniare}

\begin{defn}
  O secventa infinita $a$ cu elemente dintr-un corp $F$ se numeste recurenta
  liniara daca si numai daca exista constantele $c_{1}, c_{2}, \ldots, c_{k}$
  astfel incat
  $a_{t} = a_{t-1}c_{1} + a_{t-2}c_{2} + \ldots + a_{t-k}c_{k} \ \forall \ t > k$.
\end{defn}

\begin{defn}
  Pentru o recurenta liniara $a$ si $c_{0}, c_{1}, \ldots c_{k} \in F$, astfel
  incat
  $c_{0} a_{t} = a_{t-1}c_{1} + a_{t-2}c_{2} + \ldots + a_{t-k}c_{k} \ \forall \ t > k$,
  atunci polinomul $c_{0} x^{k} + c_{1} x^{k-1} + \ldots + c_{k} x^{0}$ se
  numeste anihilator al lui $a$.
\end{defn}

\begin{defn}
  Un ideal al unui inel $R$ generat de $S \subset R$ este
  $\{f = \sum_{i=1}^{r} x_{i}s_{i} \ | \ r \in \mathbb{N}, \ s_{i} \in S, x_{i} \in R\}$.
\end{defn}

\begin{defn}
  Un ideal $<S>$ dintr-un inel $R$ este de tip finit daca admite un sistem finit de generatori:
  $\exists \ s_{1}, s_{2}, \ldots s_{r} \in \ <S>$  astfel incat
  $\forall \ s \in \ <S>, s = \sum_{i=1}^{r} x_{i} s_{i}, \ x_{i} \in R$.
\end{defn}

\begin{defn}
  Un ideal se numeste principal daca admite un sistem de generatori format
  dintr-un singur element.
\end{defn}

\begin{defn}
  Inelul $R$ se numeste principal daca orice ideal este principal.
\end{defn}

\begin{thm}
  $F[x]$ este un inel principal.
\end{thm}

\begin{lem}
  Anihilatoarele lui $a$ formeaza un ideal in $F[x]$.
\end{lem}

\begin{clr}
  Idealul format din anihilatoarele lui $a$ este generat de un polinom monic de
  grad minim. Acesta se numeste polinomul minim al lui $a$.
\end{clr}

\begin{thm}
  Functia generatoare $A(x) = \sum_{n=0}^{\infty} a_{n}x^{n}$ este rationala:
  $A(x) = \frac{P(x)}{Q(x)}$ unde $deg(P) < k$, iar $Q(x) = 1 - \sum_{i=1}^{k} c_{i}x^{i}$.
\end{thm}

\begin{thm}
  Daca stim ca gradul polinomului minim este cel mult $m$, atunci acesta este
  unic determinat de primele $2m$ elemente ale lui $a$; sau altfel spus
  $P(x) \equiv Q(X) A(X) \mod x^{2m}$.
\end{thm}

\textbf{Identitatea lui Bezout}: daca $g$ este cel mai mare divizor comun al
polinoamelor $a$ si $b$, atunci exista doua polinoame $u$ si $v$ astfel incat
$ua + vb = g$.

In \cite{sugiyama} se arata ca putem executa algoritmul lui Euclid extins pentru
calcularea valorilor $u$ si $v$, alegand $a = A(x) \mod x^{2m}$, iar
$b = x^{2m}$ pana cand $deg(g) < m$.

\pagebreak

\section{Filtrare prin radacini ale unitatii}

\label{rootsofunityfilter}

\textbf{Filtrarea prin radacini ale unitatii} este o tehnica de izolare si
insumare a coeficientilor unui polinom. Aceasta se preteaza, in particular,
atunci cand indexurile sunt periodice modulo $n$.

\begin{thm}
  Daca $p$ este un polinom si $\zeta$ este o radacina a unitatii de ordin
  $n$ ($\zeta^{n} = 1$), atunci $\frac{1}{n} \sum_{i=0}^{n-1} p(\zeta^{i})$
  este suma indexurilor dizibile prin $n$.
\end{thm}

\begin{proof}
  Fie $p = a_{0}x^{0} + a_{1}x^{1} + \ldots + a_{k}x^{k}$. Consideram contributia
  unui index $p$, nedivizibil prin $n$ la suma
  $\sum_{i=0}^{n-1} p(\zeta^{i}) = a_{p}(\zeta^{0} + \zeta^{p} + \zeta^{2p} + \ldots + \zeta^{(n-1)p})$.
  Termenul din partea dreapta este de fapt $\sum_{i=0}^{n-1} \zeta^{i*p} = \frac{\zeta^{p*n} - 1}{\zeta^{p} - 1} = 0$,
  deci se anuleaza. Celelalte indexuri vor avea coeficient $1$ pentru fiecare
  $\zeta^{i}$, deci se vor aduna in total de $n$ ori, motiv pentru care toata suma
  se imparte la $n$.
\end{proof}


\pagebreak

\section{Radacini primitive}

In ce urmeaza presupunem ca lucram intr-un corp finit $\mathbb{F}_{p}$, unde $p$ este un numar prim.

\begin{defn}
  Un numar $g$ se numeste radacina primitiva modulo $n$ daca si numai daca pentru orice $a$ coprim cu $p$ exista un alt numar
  $l$ astfel incat $g^{l} = a \mod p$.
\end{defn}

\begin{thm}
  \label{carmichael}
  (Functia Carmichael) Fie $g$ o radacina primitiva, atunci cel mai mic numar $l$ astfel incat $g^{l} = 1$ este $\phi(p)$.
\end{thm}

\begin{thm}
  \label{carmichaelr}
  Reciproca teoremei \ref{carmichael} este adevarata si sta la baza algoritmului pentru aflarea generatorului.
\end{thm}

Un algoritm evident pentru a cauta radacini primitive incearca numerele din $\mathbb{F}_{p}$ pe rand si apoi le calculeaza
puterile pentru a verifica daca sunt diferite. Desi in general radacina primitiva este un numar destul de mic, acest algoritm
nu este cel mai eficient posibil.

Din \ref{carmichaelr} stim ca, pentru un $a$ fixat, daca gasim un $l < \phi(p)$ pentru care $a^{l} = 1$, atunci acesta nu este un
generator. Din \textbf{teorema lui Euler} stim ca orice $a$ coprim cu $p$ satisface $a^{\phi(p)} = 1 \mod p$. Aceste observatii pot
imbunatati algoritmul mentionat anterior, insa, pentru ca noi il folosim pentru $p$ numar prim, atunci $\phi(p) = p - 1$, deci nu
ajuta foarte mult. \textbf{Teorema lui Lagrange} mai spune ca este suficient sa verificam ca $a^{d} \neq 1 \mod p$ pentru toti $d \ |\ \phi(p)$.
Aceasta este deja o imbunatatire foarte mare, deoarece numarul de divizori ai lui $\phi(p)$ este de ordinul $O(p^{\frac{1.066}{\ln \ln p}})$.

Daca $\phi(p) = a_{1}^{b_{1}} a_{2}^{b_{2}} \ldots a_{t}^{b_{t}}$, atunci este de ajuns sa se verifice acei $d = \frac{\phi(p)}{a_{i}}$.

\begin{proof}
  Presupunem ca exista un divizor propriu $d$ al lui $\phi(p)$ astfel incat $g^{d} = 1 \mod p$. Atunci exista un factor prim $a_{i}$
  din factorizarea lui $\phi(p)$ astfel incat $d \ | \ \frac{\phi(p)}{a_{i}}$ si evident $g^{\frac{\phi(p)}{a_{i}}} = 1 \mod p$.
\end{proof}

Complexitatea de timp a acestei solutii este acum $O(g \log^{2} p)$, iar daca presupunem ca ipoteza Riemann ca fiind adevarata, $g = O(\log^{6} p)$.
