\chapter{Concluzie}

Problemele de optimizare mereu mi s-au părut o parte fascinantă a informaticii.
Exemplele și tehnicile ilustrate în lucrare creează o bază solidă în ceea ce
înseamnă metode alternative pentru calculul cuplajelor în grafuri bipartite.
Desigur, se pot pune întrebări cât de util este să aflăm ce valori diferite
de xor pe muchii putem obține din toate cuplajele perfecte? În formă aceasta
poate părea ceva de nișă fără vreo aplicabilitate practică, însă aceasta stă de
fapt la baza multor altor problemele întâlnite în informatică, cum ar fi:

\begin{itemize}
  \item În teoria jocurilor, soluția faimosului joc NIM este să determini dacă
    suma xor a valorilor din șir este sau nu nenula. Astfel, putem folosi soluția
    problemei pentru a determina dacă există măcar un cuplaj perfect cu suma xor 0.

  \item Cum am văzut și în soluțiile parțiale care foloseau programare dinamică pe
    submultimi, numerele în baza 2 pot reprezenta de fapt o submultime de obiecte,
    iar pentru că nu există transport în cazul adunării xor, obiectele diferite nu
    se vor influența.

  \item Ideea precedentă se poate extinde și pentru alte baze de numeratii, deoarece
    și transformarea Walsh Hadamard se poate \cite{whtbase}. Astfel se poate implementa
    adunarea vectorilor de pe muchiile cuplajului în $\mathbb{Z}_p$. Spre exemplu,
    poate ne interesează să găsim un cuplaj perfect unde pe muchii sunt $K$ tipuri
    de obiecte care trebuie împărțite egal la $p$ oameni. În acest caz lucrăm cu
    numere de $K$ cifre în baza $p$ și dorim iar să obținem suma ``xor'' 0.
\end{itemize}

Și sunt sigur că mai putem găși multe alte exemple care par mult mai familiare,
dar se pot reduce și ele la ``Xor Matching''. De asemenea putem să o extindem în
feluri diferite. Ce proprietăți are operație xor pentru care am putut să rezolvăm
problema? Transformarea Walsh Hadamard se poate modifica pentru a rezolva operații
arbitrare atâta timp cât se găsesc matricele de transformare, cum ar fi or pe biți
sau and pe biți.

Toate problemele s-au rezolvat în contextul matricei Edmonds, însă există o extensie
directă a acesteia pentru grafuri oarecare, matricea Tutte \cite{tutte}. Ce
proprietăți pierdem când facem trecerea și care dintre probleme rămân valabile
odată ce facem această schimbare? În această lucrare am introdus algoritmul de
cuplaj de cost minim pe muchii \ref{mincostmatching}, iar aceasta se știe că este
o problema care admite un algoritm polinomial și pentru grafuri oarecare, dar care
nu este bazat pe flux, dar pe un algoritm similar cu cel ungar în combinație cu
metoda ``Blossom'' inventată de către Jack Edmonds. Acesta a fost considerat mult
timp un algoritm mai complicat de înțeles și implementat iar o metodă bazată pe
algoritmi de algebră liniară și matricea Tutte ar fi o alternativă tentantă, mai
ales în cadrul concursurilor de programare competitivă.

Am pus deja destul de mult accent pe asta, dar consider că programarea competitivă
și cercetarea în informatică au o corelație foarte puternică și mi-aș dori să văd
în viitor mai multe lucrări că aceasta, care se află la marginea dintre cele două.
